""" 
    UE5_envs.py
"""
from .bridge.TCP_IP_Connector import ClientHandler
from gymnasium import Env as gymEnv

import gymnasium.spaces as spaces
import numpy as np

from cartpole_engine.envs.spaces import BridgeSpaces

class BridgeEnv(gymEnv): 
    """
        Base class for custom UE5 Conenction. 
    """
    # 1. Custom gymenv metadata for viz. 
    metadata = {
        "rendermodes": [""], 
        "render_fps": ""
    }

    def __init__(self, name, ip, port, config, first_connection = False, validation = False, multiagent = False):
        self.ip = ip # IP Address for IP Connection 
        self.port = port 
        
        self.name = name # environment name for later id 

        self.observation_config = config["observation"]
        self.action_config = config["action"]

        self.has_handler = False # ClientHandler to begin with connection
        self.has_connection = False

        self.validation = validation
        self.multiagent = multiagent 

        self.obs = [0]
        try: 
            self.observation_space = self.observation_config["space"] # Get imported space 
            self.action_space = self.action_config["space"]
        except: 
            raise ValueError("No correct space selected")

        # if first_connection:
        #     self.handler = ClientHandler(self.ip, self.port)

        self.create_handler()

    
    def step(self, action): 

        if not self.has_connection:
            self.connect()

        action=np.array(action,dtype=np.single)

        if isinstance(action, list): 
            action = np.array(action)
        elif isinstance(action, np.ndarray):
            pass
        else:
            assert "No valid action type. Only supports <list> or <numpy.ndarray> given %s" % (type(action))
        
        obs = self.obs 

        #terminated = self.check_termination(obs) # Check for validation to continue 
        #action = np.insert(action, 0, np.single(terminated))
        
        print('[ACTION]', end=" ")
        print(action)

        # 2. Cast the action vector to a byte buffer for send.
        action_buff = action.tobytes()
        n = self.get_amount_obs()
        # 3. Send the action vector to the environment. 
        self.handler.send(action_buff) # Send action an wait response 
        data_size = 8*(n+2)

        state = self.handler.recv(data_size) # Get state vetor 
        obs = state[0:n]
        self.obs = obs 
       
        # 4. Rewards System
        # For each frame within the termination limits, 
        ##reward = self.counter
        
        reward = state[n]
        terminated = bool(state[n+1])

        

        # 4. Rewards System
        # For each frame within the termination limits, 
        # self.counter += 1
        # reward = self.counter
        #reward = 0

        # Additional metadata [ignore ]
        truncated = False
        info = {}

        return obs, reward, terminated, truncated, info

    
    def reset(self, *, seed=None, options=None):
        print('[OBS]:', self.get_amount_obs())
        return np.zeros((self.get_amount_obs(),), dtype = np.double), {}

    def get_multiagent_state_dict(received_vector: np.array): 
        state = {}

        

        

        return 
    def check_termination(self, obs):
        """
            Check Termination 
            ---
            Verify if the episode must continue under a set of conditions 

        """
        terminated = False

        return terminated

    def get_amount_obs(self):
        return self.observation_space.shape[0]
    
    def which_observation(self): 
        """
            Which Obs
            ---
            Print description of the observation space in the environment. 
            Amount of elements per observation and fundamental structure. 
        """
        print(f"action dim: {self.observation_space}")

    def which_action(self): 
        """
            Which Obs
            ---
            Print description of the observation space in the environment. 
            Amount of elements per observation and fundamental structure. 
        """
        print(f"action dim: {self.action_space_dim}")

    def summary(self): 
        """
            Summary
            ---
            Prints the basic structure of the given space. Observation and 
            Actions structures, environment nameid and metadata 
        """
        TEXT_OFFSET = 80
        
        print("")
        print("THIS IS A AUTOGENERATED SUMMARY FOR THE CUSTOM BRIDGE ENV")
        print("--- ")

        print("\nEnvironment: \"{}\"".format(self.name))
        print("This is a gymnasium environment that connects to UE5 via TCP/IP")
        print(f"ip address: {self.ip}\t\t port: {self.port}")
        print("_" * TEXT_OFFSET)
        print("Feature\t\t\t\tType\t\t\t\tShape")
        print("=" * TEXT_OFFSET)

        print("Observation\t\t\t{}\t\t\t\t{}".format(
            self.get_space_type_instance(self.observation_space), # self.get_space_type_id(self.observation_config["type"]),
            self.observation_space.shape)
            )
        
        print("Action\t\t\t\t{}\t\t\t\t{}".format(
              self.get_space_type_instance(self.action_space), # self.get_space_type_id(self.observation_config["type"]),
             self.action_space.shape)
            )
        print("_"* TEXT_OFFSET)        
        print("")

        # print("\nSocket Connection Parameters")
        # print(f" -IP: {self.ip}\n -port: {self.port}")


    # def get_space_type_id(self, id):
    #     """
    #         Get space type id 
    #         ---

    #     """
    #     dic = {
    #         myspaces.BOX_SPACE:           "Box Space", 
    #         myspaces.DISCRETE_SPACE:      "Discrete Space", 
    #         myspaces.MULTIBINARY_SPACE:   "Multibinary Space", 
    #         myspaces.MULTIDISCRETE_SPACE: "Multidiscrete Space", 
    #     }
    
    #     return dic[id]
    
    def get_space_type_instance(self, is_instance_object):
        """
            Get space type from instance. 

            Take the space instance. Depending on its class, returns a string 
            identificator the representes the given space. 

            Arguments 
            ---
            - is_instance_object: instance of the space class to compare 

            Returns
            ---
            - String identificator of the space to convert. 

        """
        if isinstance(is_instance_object, BridgeSpaces.Box):
            return "Box Space"
        elif isinstance(is_instance_object, BridgeSpaces.Discrete):
            return "Discrete Space"
    
        return "N/A"

    def create_handler(self): 
        self.handler = ClientHandler(self.ip, self.port) # Create a Handler 
        self.has_handler = True 

    def validate_handler(self): 
        return self.has_handler
        
    def connect(self):
        if self.has_handler:
            self.has_connection = self.handler.connect()
        
        
    def shutdown_server(self):
        """
            Shutdown Server 
            ---

        """
        self.handler.close()
    

